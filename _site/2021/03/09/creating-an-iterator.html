<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;0,700;1,400&family=Nunito+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/layout.css">
    <title>Creating an Iterator in Rust</title>
</head>

<body>
    <div id="nav">
    <div id="nav-inner">
        
            

            
                <a id="home" href="/">Aloso's blog</a>
            
        
            

            
                <a href="/about">About</a>
            
        
    </div>
</div>

    <div id="main">
        <div id="main-inner">
            <h1>Creating an Iterator in Rust</h1>
            
                <div id="meta">
                    09 Mar 2021
                    <span class="bullet"></span>
                    9 minutes read
                </div>
            

            <div class="paragraph">
<p>When I woke up today, I thought, what a great day to start a blog! So here we are. Before we take off, just a short introduction: I&#8217;m Ludwig, I&#8217;m a CS student from Germany, and I love Rust. Since this blog is about Rust, I hope you do too!</p>
</div>
<div class="paragraph">
<p>This post is about a core concept in Rust, iterators. If you don&#8217;t know what iterators are, please read <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">the chapter about iterators</a> in the Rust book first.</p>
</div>
<div class="sect1">
<h2 id="_the-collection-type">The collection type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Iterators usually iterate over some sort of collection. Our collection type is a tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="n">Item</span><span class="p">),</span>
    <span class="nf">Children</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">),</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Simple, right? A tree node is either a <code>Leaf</code>, in which case it contains an <code>Item</code>, or a list of child nodes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a-traverse-method">A <code>traverse</code> method</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We want to traverse (i.e. iterate over) this kind of tree <em>depth-first</em>. This means that when a node has multiple children, we first traverse the first child <em>and all its descendants</em> before moving on to the second child. This is easy to implement with a recursive algorithm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">node</span> <span class="n">in</span> <span class="n">children</span> <span class="p">{</span>
                    <span class="n">node</span><span class="nf">.traverse</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want to do something with each item, we can pass a closure to the function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">It</span><span class="p">)</span> <span class="o">+</span> <span class="n">Clone</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">f</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">node</span> <span class="n">in</span> <span class="n">children</span> <span class="p">{</span>
                    <span class="n">node</span><span class="nf">.traverse</span><span class="p">(</span><span class="n">f</span><span class="nf">.clone</span><span class="p">());</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows us to iterate over the items. However, <code>Tree</code> still doesn&#8217;t implement the <code>Iterator</code> trait, which would be useful because it provides helper methods such as <code>filter</code>, <code>fold</code> and <code>collect</code>.</p>
</div>
<div class="paragraph">
<p>As we will see shortly, implementing this trait is quite tricky in this case. The reason for this is that the <code>Iterator</code> trait provides <em>external iteration</em>, whereas our <code>traverse</code> method provides <em>internal iteration</em>.</p>
</div>
<div class="openblock hint">
<div class="title">External and internal iteration</div>
<div class="content">
<div class="paragraph">
<p>Internal iteration means that a closure is passed to a function, which calls the closure for every element. This means that the iterator function has full control over the iteration.</p>
</div>
<div class="paragraph">
<p>External iteration on the other hand means that there&#8217;s a struct with a method to get the next element. This means that the code <em>using</em> the iterator controls the iteration. It can pause the iteration, do something else, pass the iterator to another function and maybe resume it later. External iteration is therefore very powerful and flexible.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementing-the-iterator-trait">Implementing the <code>Iterator</code> trait</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To be able to <em>externally</em> iterate over the tree, we need to implement the <code>Iterator</code> trait. It looks roughly like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">trait</span> <span class="n">Iterator</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The iterator trait is usually not implemented for a collection <em>directly</em>. Instead, a <em>new type</em> is created that wraps the collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As the immutable reference indicates, this struct can only iterate over immutable references of the items. To get an instance of this type, we add a <code>.iter()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">NodeIter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can start with the actual implementation!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">It</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">todo!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now there&#8217;s a problem: Since <code>Iterator</code> provides external iteration, we have to produce one item at a time. This means that we can&#8217;t use the simple recursive algorithm we used in the <code>traverse</code> method. Instead, we have to keep track of the state of the iterator manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">children</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span><span class="p">],</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>children</code> field contains the remaining children of a node, the <code>parent</code> field is the iterator of the parent node, if present. It must be wrapped in a <code>Box</code> because a struct in Rust can&#8217;t contain itself without indirection – otherwise, it would be impossible to compute its size on the stack.</p>
</div>
<div class="paragraph">
<p>So how does this work? When we create the iterator, we put the node into the <code>children</code> slice and set <code>parent</code> to <code>None</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">NodeIter</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">slice</span><span class="p">::</span><span class="nf">from_ref</span><span class="p">(</span><span class="k">self</span><span class="p">),</span>
            <span class="n">parent</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When the iterator is advanced, we first check if <code>children</code> is empty. If that&#8217;s the case, we try to continue iterating the parent node. If there is no parent node, we return <code>None</code>.</p>
</div>
<div class="paragraph">
<p>If <code>children</code> is not empty, we remove the first child and check its variant. If it is a <code>Node::Leaf</code>, we return its content; if it is a <code>Node::Children</code>, we create a new iterator for the children. The <code>parent</code> field is set to <code>self</code>, and <code>self</code> is replaced with the newly created iterator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">mem</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="n">Iterator</span> <span class="k">for</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">It</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.children</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="k">self</span><span class="py">.parent</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c">// continue with the parent node</span>
                    <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
                    <span class="k">self</span><span class="nf">.next</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.children</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.children</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="n">children</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.children</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.children</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>

                <span class="c">// start iterating the child trees</span>
                <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="n">NodeIter</span> <span class="p">{</span>
                    <span class="n">children</span><span class="p">:</span> <span class="n">children</span><span class="nf">.as_slice</span><span class="p">(),</span>
                    <span class="n">parent</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="k">self</span><span class="p">))),</span>
                <span class="p">};</span>
                <span class="k">self</span><span class="nf">.next</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t work yet, because <a href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>mem::take()</code></a> requires that <code>NodeIter</code> implements <code>Default</code>. But this can be fixed easily:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Default</span> <span class="k">for</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">NodeIter</span> <span class="p">{</span> <span class="n">children</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[],</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="openblock hint">
<div class="title">The <code>mem::take()</code> function</div>
<div class="content">
<div class="paragraph">
<p><a href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>mem::take()</code></a> replaces a mutable reference with its default value and returns the previous value. The previous value is effectively <em>moved out</em> of the reference. We use it here to convert <code>&amp;mut self</code> to an owned value, because <code>parent</code> must be owned.</p>
</div>
</div>
</div>
</div>
</div>
        </div>
    </div>
    <div id="footer">
    <div id="footer-inner">
        &copy; Ludwig Stecher
        <span class="bullet"></span>
        <a href="https://github.com/Aloso">GitHub</a>
        <span class="bullet"></span>
        <a href="https://github.com/Aloso/aloso.github.io/">Found a typo?</a>
    </div>
</div>

</body>
</html>
