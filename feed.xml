<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://aloso.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://aloso.github.io//" rel="alternate" type="text/html" /><updated>2023-05-30T03:58:22+00:00</updated><id>https://aloso.github.io//feed.xml</id><title type="html">Aloso’s blog</title><subtitle>Posts around the Rust programming language</subtitle><entry><title type="html">We don’t need revenge</title><link href="https://aloso.github.io//2023/05/30/accountability.html" rel="alternate" type="text/html" title="We don’t need revenge" /><published>2023-05-30T00:00:00+00:00</published><updated>2023-05-30T00:00:00+00:00</updated><id>https://aloso.github.io//2023/05/30/accountability</id><content type="html" xml:base="https://aloso.github.io//2023/05/30/accountability.html"><![CDATA[<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Mob_rule">Mob justice</a> is when a person suspected to be a criminal is beaten by a group of people or crowd with clubs, stones, machetes, or anything they can lay their hands on</p>
</div>
</blockquote>
<div class="attribution">
&#8212; <a href="https://en.wikipedia.org/wiki/Mob_justice_in_Ghana">Wikipedia</a>
</div>
</div>
<div class="paragraph">
<p>Is this what the Rust community wants?</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t know what I mean, I&#8217;m talking about <a href="https://www.reddit.com/r/rust/comments/13uidp3/accountability_requires_courage/">this Reddit thread</a>, which asks for courage and accountability from the Rust project leadership. That sounds reasonable, who doesn&#8217;t want the leaders to be accountable? The problem is in how they want to achieve it: By asking Rust project members to "name and shame" the people who messed up. But what happens then?</p>
</div>
<div class="sect1">
<h2 id="background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It started with <a href="https://thephd.dev/i-am-no-longer-speaking-at-rustconf-2023">this blog post</a>, where ThePHD explained why they are no longer speaking at RustConf 2023. Some people from the Rust project had reservations about ThePHD&#8217;s work, but it&#8217;s unclear who exactly. Since then, a shitstorm has unfolded as more and more alarming details have come to light. Someone in the Rust leadership even <a href="https://www.jntrnr.com/why-i-left-rust/">resigned in protest</a>, and a well-known Rust educator also <a href="https://gist.github.com/fasterthanlime/42da9378768aebef662dd26dddf04849">ended his involvement</a>. Now, the Rust project leadership has <a href="https://blog.rust-lang.org/2023/05/29/RustConf.html">apologized</a> and said that the people responsible have resigned from their positions. Of course, people want to know who in the Rust project was responsible.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="accountability-whatever-that-means">Accountability, whatever that means</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Rust community has always been perceived as happy and welcoming, and we are proud of that. We have made it possible for anyone, regardless of background, to learn the language, contribute, and propose new features. Changes must follow the RFC process, which is based on <a href="https://en.wikipedia.org/wiki/Consensus_decision-making">consensus</a>, and communication happens in the open&#8230;&#8203; mostly. Some decisions are time critical or involve personal/confidential information, so we don&#8217;t know everything the Rust leadership does.</p>
</div>
<div class="paragraph">
<p>What does accountability mean? According to <a href="https://en.wikipedia.org/wiki/Accountability">Wikipedia</a>, it means <em>"A is accountable to B when A is obliged to inform B about A&#8217;s (past or future) actions and decisions, to justify them, and to suffer punishment in the case of eventual misconduct" and more.</em></p>
</div>
<div class="paragraph">
<p>Accountability is important to ensure that people act responsibly. But to whom should Rust&#8217;s leadership be accountable? There are three options:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>They are accountable to each other</p>
</li>
<li>
<p>They are accountable to another person or group, like a control gremium</p>
</li>
<li>
<p>They are accountable to the wider Rust community</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The last option doesn&#8217;t really make sense though: When an event or decision affects the public, the public should be informed in the interest of transparency. But when someone does something wrong, the public is not in a position to punish the person appropriately, or to fix the problem.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-ethics-of-punishment">The ethics of punishment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Every government has a justice system for punishing criminals, even though we don&#8217;t know exactly what “justice” means. People seem to have an innate sense of justice, but it is coupled with our emotions. To justify punishment, it must be <strong>useful</strong>, and of course there are quite a few reasons why punishment is useful:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It prevents the criminal from doing it again</p>
</li>
<li>
<p>It discourages others from doing anything illegal</p>
</li>
<li>
<p>The criminal gets to repent and feel less guilty after accepting the punishment</p>
</li>
<li>
<p>The victim may feel vindicated by getting “revenge”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But before punishing someone, we must first understand why the criminal did it. Most people (including criminals) are not evil psychopaths, and understanding their perspective is important to figure out what to do with them. Therefore, a criminal has the right to a fair trial in any <a href="https://en.wikipedia.org/wiki/Rechtsstaat">Rechtsstaat</a> (legal system).</p>
</div>
<div class="paragraph">
<p>Now, the Rust project is not a government, but it can still punish someone by banning them or removing them from their leadership position. Of course that person should be given a chance to justify their actions. When someone behaves badly, it&#8217;s usually an accident, often caused by bad communication.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-do-we-need-to-know-whose-fault-it-was">Why do we need to know whose fault it was?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We don&#8217;t, because it wouldn&#8217;t help anyone. I would support it if the people who treated ThePHD harshly apologized <em>on their own terms</em>. But outing them without their permission is not acceptable: It puts them at risk of <a href="https://en.wikipedia.org/wiki/Online_shaming">online shaming</a>, which goes against everything that Rust stands for. And even though online shaming can be seen as a punishment for their actions, there are two problems:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Without a trial, we don&#8217;t know what punishment they deserve.</p>
</li>
<li>
<p>A punishment should never violate someone&#8217;s dignity, no matter how serious the crime.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As long as we don&#8217;t have all the information, all we can do is speculate (which doesn&#8217;t mean that we should). Unsurprisingly, the people within the project, who <em>do</em> have all the information, already <a href="https://blog.rust-lang.org/2023/05/29/RustConf.html">took steps</a> to resolve the conflict and punish those who messed up. The Rust project isn&#8217;t perfect, no organization consisting of humans is. But I do think they are trying their best.</p>
</div>
</div>
</div>]]></content><author><name>Ludwig Stecher</name></author><category term="Politics" /><summary type="html"><![CDATA[Mob justice is when a person suspected to be a criminal is beaten by a group of people or crowd with clubs, stones, machetes, or anything they can lay their hands on &#8212; Wikipedia]]></summary></entry><entry><title type="html">A zero-overhead linked list in Rust</title><link href="https://aloso.github.io//2021/04/12/linked-list.html" rel="alternate" type="text/html" title="A zero-overhead linked list in Rust" /><published>2021-04-12T00:00:00+00:00</published><updated>2021-04-12T00:00:00+00:00</updated><id>https://aloso.github.io//2021/04/12/linked-list</id><content type="html" xml:base="https://aloso.github.io//2021/04/12/linked-list.html"><![CDATA[<div class="paragraph">
<p>Let&#8217;s implement an immutable, singly-linked list. <em>Singly-linked</em> means that each node contains a reference to the next node, but not vice versa. To make this data structure really performant, let&#8217;s use plain references instead of heap-allocated types. This would be dangerous in memory-unsafe languages like C, because it could easily cause vulnerabilities because of dangling pointers, but Rust&#8217;s lifetimes protect us from this. We&#8217;ll see what this means in a moment.</p>
</div>
<div class="sect1">
<h2 id="implementation">Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The implementation is fairly simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">enum</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Tail</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So a list is either a node containing some data and a reference to the next node, or the <em>tail</em>, i.e. the end of the list. Let&#8217;s write a <code>Default</code> implementation that creates an empty list, which is just <code>List::Tail</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nn">List</span><span class="p">::</span><span class="n">Tail</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now how do we add elements to the list? As I mentioned above, this list is <em>immutable</em>, so altering a list is not possible. Instead, let&#8217;s introduce a concept from functional programming: Persistent data structures</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="persistent-data-structures">Persistent data structures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>According to <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">wikipedia</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>A persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>We can achieve this by prepending a node at the front of the list: The previous list stays the same, but we get a new node pointing to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nn">List</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="k">self</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try it out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_add</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="nn">List</span><span class="p">::</span><span class="n">Tail</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tail</span><span class="nf">.add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">second</span> <span class="o">=</span> <span class="n">first</span><span class="nf">.add</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="nn">List</span><span class="p">::</span><span class="n">Tail</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="nn">List</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">List</span><span class="p">::</span><span class="n">Tail</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="nn">List</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">List</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="n">next</span><span class="p">:</span> <span class="o">&amp;</span><span class="nn">List</span><span class="p">::</span><span class="n">Tail</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">});</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For this to work, we need to implement <code>Debug</code> and <code>PartialEq</code> for our type. While we&#8217;re at it, let&#8217;s also implement some other useful traits. Note that we can even implement <code>Copy</code>, since <code>next</code> is just a reference, not a <code>Box</code> or <code>Rc</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[derive(Debug,</span> <span class="nd">Clone,</span> <span class="nd">Copy,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it! Now we can test it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="o">&gt;</span> cargo <span class="nb">test</span> <span class="nt">-q</span>

running 1 <span class="nb">test</span>
<strong class="green">.</strong>
<span class="nb">test </span>result: <strong class="green">ok</strong>. 1 passed<span class="p">;</span> 0 failed<span class="p">;</span> 0 ignored<span class="p">;</span> 0 measured<span class="p">;</span> 0 filtered out<span class="p">;</span> finished <span class="k">in </span>0.00s</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="writing-an-iterator">Writing an iterator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a functional language, we&#8217;d use this data structure mainly in recursive functions. It is, after all, a recursive data structure. But since this is Rust, let&#8217;s implement an <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> for our type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">ListIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">ListIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="na">.0</span> <span class="p">{</span>
            <span class="nn">List</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">next</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="na">.0</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nn">List</span><span class="p">::</span><span class="n">Tail</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This is a by-reference iterator. Writing an iterator that owns the element is not possible. This is a fundamental limitation of this list type, since the nodes are behind shared references.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can also implement <code>IntoIterator</code> to make iterating over a <code>List</code> easier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">IntoIterator</span> <span class="k">for</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">type</span> <span class="n">IntoIter</span> <span class="o">=</span> <span class="n">ListIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">IntoIter</span> <span class="p">{</span>
        <span class="nf">ListIter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s test this as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_iterator</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="nn">List</span><span class="p">::</span><span class="n">Tail</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tail</span><span class="nf">.add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">second</span> <span class="o">=</span> <span class="n">first</span><span class="nf">.add</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">values</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span>
        <span class="n">second</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But wait! Why are the values in the opposite order of how we added them? That&#8217;s because the <code>add</code> function prepends nodes at the start of the list. We can think of it like a stack of books: We can put books on top of it, and we can take books from it, but only in the opposite order.</p>
</div>
<div class="paragraph">
<p>Can&#8217;t we just use <code>.rev()</code> to iterate in reverse direction? Let&#8217;s try it:</p>
</div>
<div class="listingblock compile-error">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">values</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="n">second</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><strong class="red">error[E0277]</strong>: the trait bound <code>ListIter&lt;'_, {integer}&gt;: DoubleEndedIterator</code> is not satisfied
  --&gt; src/lib.rs:78:28
   |
78 |     second.into_iter().rev().copied().collect();
   |                        <span class="red">^^^ the trait <code>DoubleEndedIterator</code> is not implemented for <code>ListIter&lt;'_, {integer}&gt;</code></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So it doesn&#8217;t work. To make it work, we&#8217;d have to implement the <code>DoubleEndedIterator</code> trait, but that can&#8217;t be done very efficiently, because a list node can&#8217;t access its previous node. Then let&#8217;s try a different approach!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="internal-iteration">Internal iteration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Iterating over the list in reverse order can be done efficiently, if we use a <em>recursive algorithm</em>. This doesn&#8217;t work with the design of <code>Iterator</code> trait, so we&#8217;ll just implement it as an <em>internal iterator</em>, i.e. a function that accepts a closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">rev_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nn">List</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">next</span> <span class="p">}</span> <span class="o">=</span> <span class="k">self</span> <span class="p">{</span>
            <span class="n">next</span><span class="nf">.rev_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="nf">f</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We call <code>rev_iter</code> recursively.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Because we want to iterate in reverse, we call the closure <em>after</em> the recursive function call.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This has the downside that we can&#8217;t use iterator combinators like <code>filter</code> or <code>map</code>. It also doesn&#8217;t allow error handling in the closure, but we can add one more internal iterator that stops iterating when the closure returns an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// snip</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">try_rev_iter</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">E</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">E</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nn">List</span><span class="p">::</span><span class="n">Node</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">next</span> <span class="p">}</span> <span class="o">=</span> <span class="k">self</span> <span class="p">{</span>
            <span class="n">next</span><span class="nf">.try_rev_iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="nf">f</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nf">Ok</span><span class="p">(())</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;m omitting the test here, but you can read it in the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fbd969411281665b92a9884cd8d8bbbb">playground</a>, or you can implement it as an exercise.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="limitations">Limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This type of list isn&#8217;t useful very often. One reason for this is that it can only be iterated over by-reference. The other reason I&#8217;ll demonstrate now. Let&#8217;s try to create a function that constructs a <code>List</code> and returns it:</p>
</div>
<div class="listingblock compile-error">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="n">too_bad</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="nn">List</span><span class="p">::</span><span class="n">Tail</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">tail</span><span class="nf">.add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span><span class="nf">.add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">v2</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><strong class="red">error[E0515]</strong>: cannot return value referencing local variable <code>tail</code>
   --&gt; src/lib.rs:107:5
    |
105 |     let v1 = tail.add(1);
    |              <span class="blue">---- <code>tail</code> is borrowed here</span>
106 |     let v2 = v1.add(2);
107 |     v2
    |     <span class="red">^^ returns a value referencing data owned by the current function</span>

<strong class="red">error[E0515]</strong>: cannot return value referencing local variable <code>v1</code>
   --&gt; src/lib.rs:107:5
    |
106 |     let v2 = v1.add(2);
    |              <span class="blue">-- <code>v1</code> is borrowed here</span>
107 |     v2
    |     <span class="red">^^ returns a value referencing data owned by the current function</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So this doesn&#8217;t work. We can&#8217;t return a list if it was created in the current function. How about a function that adds elements to a list in-place?</p>
</div>
<div class="listingblock compile-error">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="n">doesnt_work</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">old_list</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
    <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">old_list</span><span class="nf">.add</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><strong class="red">error[E0597]</strong>: <code>old_list</code> does not live long enough
   --&gt; src/lib.rs:112:13
    |
110 | fn doesnt_work&lt;'a&gt;(list: &amp;'a mut List&lt;'a, i32&gt;) {
    |                <span class="blue">-- lifetime <code>'a</code> defined here</span>
111 |     let old_list = std::mem::take(list);
112 |     *list = old_list.add(5);
    |             <span class="red">^^^^^^^^</span><span class="blue">-------</span>
    |             <span class="blue">|</span>
    |             <span class="red">borrowed value does not live long enough</span>
    |             <span class="blue">argument requires that <code>old_list</code> is borrowed for <code>'a</code></span>
113 | }
    | <span class="blue">- <code>old_list</code> dropped here while still borrowed</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That doesn&#8217;t work either. This probably doesn&#8217;t come as a surprise if you&#8217;re familiar with Rust&#8217;s ownership rules: When we return a list, it can&#8217;t borrow anything defined in the current function. If Rust didn&#8217;t prevent this, we could accidentally get a <em>dangling reference</em>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">What&#8217;s a dangling reference?</div>
<div class="paragraph">
<p>All local variables live on the <em>stack</em>. Let&#8217;s use the analogy of a pile of books again: When a function is called, a new book is placed on the stack, and when the function exits, the book is removed. A dangling reference is a reference into a book that has already been removed from the stack. However, if a different book is then put in its place, its memory is overwritten, so the reference becomes invalid. Luckily for us, Rust&#8217;s borrow checker prevents references from becoming dangling.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-case">Use case</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So when is this type useful? When you need to efficiently add nodes to a list without modifying the original list, and the limitations above are not a problem.</p>
</div>
<div class="paragraph">
<p>One example that comes to mind is an interpreter for a stack-based programming language. Here&#8217;s a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[derive(Clone,</span> <span class="nd">PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Value</span> <span class="p">{</span>
    <span class="nf">Num</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
    <span class="nf">Bool</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
    <span class="nf">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">Expr</span> <span class="p">{</span>
    <span class="nf">Value</span><span class="p">(</span><span class="n">Value</span><span class="p">),</span>
    <span class="nf">Variable</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nf">UnExpr</span><span class="p">(</span><span class="n">UnExprKind</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">BinExpr</span><span class="p">(</span><span class="n">BinExprKind</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">Define</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nf">IfThenElse</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">UnExprKind</span> <span class="p">{</span>
    <span class="n">Not</span><span class="p">,</span>
    <span class="nb">Neg</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(PartialEq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">BinExprKind</span> <span class="p">{</span>
    <span class="c1">// Arithmetic</span>
    <span class="nb">Add</span><span class="p">,</span>
    <span class="nb">Sub</span><span class="p">,</span>
    <span class="nb">Mul</span><span class="p">,</span>
    <span class="nb">Div</span><span class="p">,</span>

    <span class="c1">// Logic</span>
    <span class="n">And</span><span class="p">,</span>
    <span class="n">Or</span><span class="p">,</span>
    <span class="n">Equals</span><span class="p">,</span>
    <span class="n">NotEquals</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This programming language has three data types, numbers, booleans and strings. Numbers support basic arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), booleans support logic operations (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>==</code>, <code>!=</code>). Operations are divided into <em>unary</em> operations (those with only one operand) and <em>binary</em> operations (those with two operands).</p>
</div>
<div class="paragraph">
<p>The programming language is expression-based, so everything is an expresssion. An expression can be a value, a variable, a unary or binary operation, a variable definition, or a condition. Note that a variable definition always introduces a new scope in which the defined variable can be used. The syntax could look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><span class="k">define</span> x = <span class="mi">5</span> <span class="k">in</span>
    some_expression</code></pre>
</div>
</div>
<div class="paragraph">
<p>This defines a variable <code>x</code>, which can be used in <code>some_expression</code>. The only way to define multiple variables is to nest them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code><span class="k">define</span> x = <span class="mi">5</span> <span class="k">in</span>
    <span class="k">define</span> y = <span class="mi">42</span> <span class="k">in</span>
        x <span class="nf">+</span> y</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s implement the function that evaluates this language:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">type</span> <span class="n">Variables</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">List</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="n">Value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">eval</span><span class="p">(</span>
    <span class="n">vars</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Variables</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">expr</span> <span class="p">{</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>

        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Variable</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">vars</span>  <i class="conum" data-value="1"></i><b>(1)</b>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="o">*</span><span class="n">v</span> <span class="o">==</span> <span class="n">var</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">val</span><span class="p">)|</span> <span class="n">val</span><span class="nf">.clone</span><span class="p">()),</span>

        <span class="nn">Expr</span><span class="p">::</span><span class="nf">UnExpr</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">eval_unary</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">vars</span><span class="p">,</span> <span class="o">*</span><span class="n">expr</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nn">Expr</span><span class="p">::</span><span class="nf">BinExpr</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">exprs</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">eval_binary</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">vars</span><span class="p">,</span> <span class="n">exprs</span><span class="na">.0</span><span class="p">,</span> <span class="n">exprs</span><span class="na">.1</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Define</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exprs</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">eval</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">exprs</span><span class="na">.0</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">vars</span> <span class="o">=</span> <span class="n">vars</span><span class="nf">.add</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">));</span>  <i class="conum" data-value="2"></i><b>(2)</b>
            <span class="nf">eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vars</span><span class="p">,</span> <span class="n">exprs</span><span class="na">.1</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nn">Expr</span><span class="p">::</span><span class="nf">IfThenElse</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nf">eval</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">exprs</span><span class="na">.0</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
                <span class="nf">eval</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="k">if</span> <span class="n">b</span> <span class="p">{</span> <span class="n">exprs</span><span class="na">.1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">exprs</span><span class="na">.2</span> <span class="p">})</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">eval_unary</span><span class="p">(</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">UnExprKind</span><span class="p">,</span>
    <span class="n">vars</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Variables</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nf">eval</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="nn">UnExprKind</span><span class="p">::</span><span class="n">Not</span><span class="p">,</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Bool</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="p">(</span><span class="nn">UnExprKind</span><span class="p">::</span><span class="nb">Neg</span><span class="p">,</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">eval_binary</span><span class="p">(</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">BinExprKind</span><span class="p">,</span>
    <span class="n">vars</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Variables</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">lhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span>
    <span class="n">rhs</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">kind</span> <span class="p">{</span>
        <span class="nn">BinExprKind</span><span class="p">::</span><span class="nb">Add</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">=</span> <span class="nf">eval</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">lhs</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nn">Value</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="nf">eval</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span><span class="o">?</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Value</span><span class="p">::</span><span class="nf">Num</span><span class="p">(</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nb">None</span>
        <span class="p">}</span>
        <span class="c1">// remaining match arms omitted</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Look up the variable with the name <code>var</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Add a new variable to the list</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The full code, including tests, is in the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fbd969411281665b92a9884cd8d8bbbb">playground</a>.</p>
</div>
<div class="paragraph">
<p>Why is a linked list better than a <code>Vec</code> in this case? Because a variable should only be visible in its own scope, so when evaluating a variable definition, the list of variables should be the same afterwards as before.</p>
</div>
<div class="paragraph">
<p>One way to achieve this with a <code>Vec</code> is to clone it whenever a new variable is added, but this is quite inefficient.</p>
</div>
<div class="paragraph">
<p>An alternative is to add the variable to the <code>Vec</code> and remove it again when the variable&#8217;s scope ends. The problem with this is that it requires passing a mutable <code>Vec</code> around, so the type system can&#8217;t ensure that the <code>Vec</code>'s previous state is restored after a variable definition. A small error or even an early return could break it. This could be prevented with a <a href="https://aloso.github.io/2021/03/18/raii-guards.html">RAII guard</a>, but the solution using <code>List</code> is more elegant.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="alternatives">Alternatives</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To get around the lifetime issues, you can use reference-counted smart pointers (<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">enum</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
        <span class="n">next</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="n">Tail</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This has all the advantages of our type, except that <code>Rc</code> and <code>Arc</code> incur a slight performance overhead when creating, cloning or dropping it.</p>
</div>
<div class="paragraph">
<p>When you don&#8217;t need the list to be persistent or immutable, you can just use a <code>Vec</code> instead. This also has some overhead due to heap allocations, but in return has better cache locality. More importantly, it&#8217;s easier to use: Keeping your code maintainable and easy to read is usually more important than to squeeze out every last drop of performance. Heavy optimization is only needed in performance-critical sections of the code.</p>
</div>
<div class="paragraph">
<p>The often-cited quote &#8220;Premature optimization is the root of all evil&#8221; doesn&#8217;t mean that you shouldn&#8217;t optimize, rather that you should be clever about it. Do the most effective things to improve performance first: Choose efficient algorithms. Then benchmark your code, identify where it spends most of its time, try to optimize these parts, and verify that your optimizations actually yield an improvement. Trying to optimize code without measuring the results is a hopeless endeavor.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fin">Fin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I&#8217;m looking forward to the discussion on <a href="https://www.reddit.com/r/rust/comments/mpncp6/a_zerooverhead_linked_list_in_rust/">Reddit</a>. You can also open an issue in the <a href="https://github.com/Aloso/aloso.github.io/issues">issue tracker</a>. Until next time!</p>
</div>
</div>
</div>]]></content><author><name>Ludwig Stecher</name></author><category term="Tutorial" /><summary type="html"><![CDATA[Let&#8217;s implement an immutable, singly-linked list. Singly-linked means that each node contains a reference to the next node, but not vice versa. To make this data structure really performant, let&#8217;s use plain references instead of heap-allocated types. This would be dangerous in memory-unsafe languages like C, because it could easily cause vulnerabilities because of dangling pointers, but Rust&#8217;s lifetimes protect us from this. We&#8217;ll see what this means in a moment.]]></summary></entry><entry><title type="html">Rusts Module System Explained</title><link href="https://aloso.github.io//2021/03/28/module-system.html" rel="alternate" type="text/html" title="Rusts Module System Explained" /><published>2021-03-28T00:00:00+00:00</published><updated>2021-03-28T00:00:00+00:00</updated><id>https://aloso.github.io//2021/03/28/module-system</id><content type="html" xml:base="https://aloso.github.io//2021/03/28/module-system.html"><![CDATA[<div class="paragraph">
<p>The Rust programming language can be confusing for beginners, and the module system is one part that causes frustration particularly often. There are quite a few blog posts out there trying to explain the module system in a simple way, but I often have the feeling that they over-simplify things. So here&#8217;s my take&#8212;&#8203;a more detailed explanation of the module system.</p>
</div>
<div class="paragraph">
<p>This post assumes that you can write at least a &#8220;hello world&#8221; Rust program. It&#8217;s a rather long read, so get comfortable, maybe with a cup of tea, hot chocolate, or whatever your heart desires 😊</p>
</div>
<div class="sect1">
<h2 id="why-do-modules-exist">Why do modules exist?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modules give your code <em>structure</em>: Dividing your code into modules is like dividing your house into several rooms: Each room has a different purpose, and rooms can be locked for privacy.</p>
</div>
<div class="imageblock medium">
<div class="content">
<img src="/assets/images/2021-03-28-floor-plan.png" alt="Floor plan">
</div>
<div class="title">Figure 1. Floor plan. <a href="https://commons.wikimedia.org/wiki/File:Schmidt-Lademann_house_floor_plan.png">Source</a> (modified; <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">license</a>)</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-module-tree">The module tree</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modules are structured in a <em>hierarchy</em>, the module tree, which is similar to the file tree of the source files. There are two kinds of modules: Inline modules and “normal” modules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">mod</span> <span class="n">inline</span> <span class="p">{</span>
    <span class="c1">// content of the module</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">normal</span><span class="p">;</span>
<span class="c1">// the content is in another file</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These are functionally equivalent. If the content of an inline module is very long, move it to another file, to keep the code neat and manageable.</p>
</div>
<div class="paragraph">
<p>When the module is not inline, Rust looks for the content of the module in another file, either <code><em class="no-yellow">module_name</em>.rs</code> or <code><em class="no-yellow">module_name</em>/mod.rs</code>. It might seem odd that we have to declare modules explicitly (unlike in Python, where modules are inferred from the file system). However, there are good reasons for this, as we&#8217;ll see later.</p>
</div>
<div class="paragraph">
<p>Like every tree, the module tree has a <em>root</em>. This is the file <code>lib.rs</code> in case of a library crate, or the file <code>main.rs</code> in case of a binary crate <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
<div class="sect2">
<h3 id="submodules">Submodules</h3>
<div class="paragraph">
<p>Unfortunately, Rust is not the most consistent language when it comes to modules: There are two different ways to structure a module tree, and they can be mixed within the same crate.</p>
</div>
<div class="paragraph">
<p>Say we have a library crate with a module <code>parent</code>, which contains a sub-module <code>child</code>:</p>
</div>
<div class="listingblock file-tree">
<div class="content">
<pre class="rouge highlight"><code data-lang="source">└─ <strong class="folder">library root</strong>
   └─ <strong class="file">parent</strong>
      └─ <strong class="file">child</strong></code></pre>
</div>
</div>
<div class="paragraph">
<p>The crate root is in a <code>lib.rs</code> file in the <code>src</code> directory. However, the <code>parent</code> module can be either in a <code>parent.rs</code> file next to <code>lib.rs</code>, or in a <code>mod.rs</code> file in a <code>parent</code> directory:</p>
</div>
<div class="openblock flex">
<div class="content">
<div class="listingblock file-tree">
<div class="title">File tree A</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="source">├─ <strong class="file">Cargo.toml</strong>
└─ <strong class="folder">src/</strong>
   ├─ <strong class="file">lib.rs</strong>
   ├─ <strong class="file">parent.rs</strong>  // parent module
   └─ <strong class="folder">parent/</strong>
      └─ <strong class="file">child.rs</strong></code></pre>
</div>
</div>
<div class="listingblock file-tree">
<div class="title">File tree B</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="source">├─ <strong class="file">Cargo.toml</strong>
└─ <strong class="folder">src/</strong>
   ├─ <strong class="file">lib.rs</strong>
   └─ <strong class="folder">parent/</strong>
      ├─ <strong class="file">mod.rs</strong>  // parent module
      └─ <strong class="file">child.rs</strong></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It doesn&#8217;t really matter which way you go, just do what you prefer. I use the first way (&#8220;File tree A&#8221;), since it&#8217;s easier to add sub-modules. For example, if you want to add a submodule to <code>child</code>, you just need to create a folder and a new file, and add a <code>mod</code> declaration:</p>
</div>
<div class="listingblock file-tree">
<div class="content">
<pre class="rouge highlight"><code data-lang="source"> ├─ <strong class="file">Cargo.toml</strong>
 └─ <strong class="folder">src/</strong>
    ├─ <strong class="file">lib.rs</strong>
    ├─ <strong class="file">parent.rs</strong>
    └─ <strong class="folder">parent/</strong>
       ├─ <strong class="file">child.rs</strong>
<span class="diffadd">      └─ <strong class="folder">child/</strong></span>
<span class="diffadd">          └─ <strong class="file">grand_child.rs</strong></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The path of a module can also be specified explicitly with the <a href="https://doc.rust-lang.org/reference/items/modules.html#the-path-attribute"><code>#[path]</code></a> attribute, but this is rarely used in practice.</p>
</div>
</div>
<div class="sect2">
<h3 id="an-example">An example</h3>
<div class="paragraph">
<p>Hopefully this will make more sense once you see an example. Here&#8217;s the module structure of a library crate:</p>
</div>
<div class="listingblock file-tree">
<div class="content">
<pre class="rouge highlight"><code data-lang="source">├─ <strong class="file">Cargo.toml</strong>
└─ <strong class="folder">src/</strong>
   ├─ <strong class="file">lib.rs</strong>
   ├─ <strong class="file">foo.rs</strong>
   ├─ <strong class="file">bar.rs</strong>
   └─ <strong class="folder">bar/</strong>
      └─ <strong class="file">baz.rs</strong></code></pre>
</div>
</div>
<div class="openblock flex">
<div class="content">
<div class="listingblock">
<div class="title">lib.rs</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="c1">// root module</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">bar</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">bar.rs</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">mod</span> <span class="n">baz</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">baz</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="nn">foo</span><span class="p">::</span><span class="n">Answer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">foo.rs</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">mod</span> <span class="n">answer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">Answer</span><span class="p">(</span><span class="k">pub</span> <span class="nb">i32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">use</span> <span class="nn">answer</span><span class="p">::</span><span class="n">Answer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">baz.rs</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Answer</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">answer</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Answer</span> <span class="p">{</span>
    <span class="nf">Answer</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>No worries if you don&#8217;t understand everything here! All the concepts that are used here will be explained. You can look at this example later and see if you understand everything. For now, do you know what the module tree is?</p>
</div>
<details><summary>See solution</summary>
<div class="listingblock file-tree">
<div class="content">
<pre class="rouge highlight"><code>└─ <strong class="folder">library root</strong>  /src/lib.rs
   ├─ <strong class="file">foo</strong>        /src/foo.rs
   │  └─ <strong class="file">answer</strong>  /src/foo.rs
   └─ <strong class="file">bar</strong>        /src/bar.rs
      └─ <strong class="file">baz</strong>     /src/bar/baz.rs</code></pre>
</div>
</div>
</details>
</div>
</div>
</div>
<div class="sect1">
<h2 id="items-and-paths">Items and paths</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A module contains <em>items</em>. Items are</p>
</div>
<div class="ulist compact">
<ul>
<li>
<p>Functions</p>
</li>
<li>
<p>Types (structs, enums, unions, type aliases)</p>
</li>
<li>
<p>Traits</p>
</li>
<li>
<p>Impl blocks</p>
</li>
<li>
<p>Macros</p>
</li>
<li>
<p>Constants and statics</p>
</li>
<li>
<p>Extern blocks</p>
</li>
<li>
<p>Extern crates</p>
</li>
<li>
<p>Imports</p>
</li>
<li>
<p>Modules</p>
</li>
<li>
<p>Associated items (not important right now)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can refer to items by their <em>path</em>. For example, the path <code>foo::bar::Baz</code> refers to the <code>Baz</code> item within the <code>bar</code> item within the <code>foo</code> item. Paths are usually relative: To use <code>foo::bar::Baz</code>, the <code>foo</code> item must be available in the current scope; absolute paths (starting at the root module) are prefixed with <code>crate::</code>. A <code>super::</code> path segment changes to the parent module (similar to <code>../</code> in the file system).</p>
</div>
<div class="paragraph">
<p><em>Imports</em> are used to shorten paths. Instead of having to write <code>foo::bar::Baz</code> every time, we can write <code>use foo::bar::Baz;</code> once. This brings the item into scope, so we can refer to it with the much shorter path <code>Baz</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Changes to paths in the 2018 edition</div>
<div class="paragraph">
<p>Prior to the 2018 edition, absolute paths started with just <code>::</code> instead of <code>crate::</code>. In the 2018 edition, this syntax is still available, but it&#8217;s not recommended and can only be used for external crates.</p>
</div>
<div class="paragraph">
<p>In the 2015 edition, imports were always absolute, even when they weren&#8217;t prefixed with <code>::</code>. This was fixed in the 2018 edition for more consistency.</p>
</div>
<div class="paragraph">
<p>The 2018 edition also changed how external crates are used: In the 2015 edition, to use an external crate, an <code>extern crate</code> declaration was needed. This is no longer required in most cases: We can just put dependencies in our <code>Cargo.toml</code>, and use them right away.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="visibility">Visibility</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Visibility</em>, or <em>privacy</em>, is the concept of making parts of a module inaccessible from other modules. Things that are only accessible in the same module are called <em>private</em>, and things that are accessible everywhere are called <em>public</em>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This concept exists in many programming languages. However, in most object-oriented languages, the privacy boundary is the <em>class</em>, whereas in Rust, the modules are privacy boundaries.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In Rust, most things are private by default. To make something public, the <code>pub</code> keyword is written before it. This makes the item accessible everywhere:</p>
</div>
<div class="listingblock">
<div class="title">lib.rs</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">mod</span> <span class="n">foo</span> <span class="p">{</span>  <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">pub</span> <span class="k">mod</span> <span class="n">bar</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Baz</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// use bar::Baz;  </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">foo</span><span class="p">::</span><span class="n">bar</span><span class="p">;</span>  <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This declares a private module, so it can only be used within this root module. It can&#8217;t be accessed from another crate.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If we uncommented this, it would fail to compile. <code>Baz</code> is private, therefore it can only be used within the <code>bar</code> module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The module <code>bar</code> can be used here, because it is declared as public. This is somewhat counter-intuitive, since the <code>foo</code> module is private. But when a module is private, it can still be accessed within its direct parent module, since a module is just like any other item.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="encapsulation">Encapsulation</h3>
<div class="paragraph">
<p>When designing an API, there are often <em>invariants</em> that need to be preserved. An invariant is a property that never changes. For example, a struct might contain a value that is supposed to always be within the interval [0; 360):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="nf">Angle</span><span class="p">(</span><span class="k">pub</span> <span class="nb">f32</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s write a <code>new</code> function that validates this invariant, and a getter for the value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span> <span class="n">Angle</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="nf">Angle</span><span class="p">(</span><span class="n">value</span><span class="nf">.rem_euclid</span><span class="p">(</span><span class="mf">360.0</span><span class="p">))</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f32</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://doc.rust-lang.org/std/primitive.f32.html#method.rem_euclid"><code>rem_euclid</code></a> calculates the least nonnegative remainder of <code>self (mod rhs)</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By ensuring that the angle is always in [0; 360), we can implement operations such as equality (where 0° == 360°) very easily. But wait! Since the field is public, a user of the API can create an <code>Angle</code> object without calling the <code>new</code> function, or modify it without checking the invariant.</p>
</div>
<div class="paragraph">
<p>By making the field private, the struct&#8217;s implementation details are hidden. This is called <em>encapsulation</em>: Within this module, we still have to take special care that the invariant is preserved, but if the code is correct, the public API is impossible to use incorrectly.</p>
</div>
</div>
<div class="sect2">
<h3 id="fine-grained-visibility">Fine-grained visibility</h3>
<div class="paragraph">
<p>Items can be private or public. However, there are also visibilities in-between: Most notably, an item can be declared as <code>pub(crate)</code>. This means that it is visible <em>within the current crate</em>, but not outside. With <code>pub(super)</code>, an item is visible within the parent module. With <code>pub(in <em class="no-yellow">path</em>)</code>, visibility can also be limited to any other module as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">mod</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">super</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">pub</span><span class="p">(</span><span class="n">in</span> <span class="k">crate</span><span class="p">::</span><span class="n">foo</span><span class="p">)</span> <span class="k">struct</span> <span class="n">Baz</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When something is visible in one module, it is also visible in all its child modules. It still needs to be imported (or referred to with its path) though:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">Foo</span><span class="p">;</span>
<span class="c1">// Foo is visible in this module</span>

<span class="k">mod</span> <span class="n">inner</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Foo</span><span class="p">;</span>
    <span class="c1">// Foo is also visible here!</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="visibilities-overview">Visibilities overview</h3>
<div class="openblock min-width">
<div class="content">
<table class="tableblock frame-all grid-all fit-content fancy">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pub</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The item is visible everywhere</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pub(crate)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The item is visible in the current crate</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pub(super)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The item is visible in the parent module</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pub(in&nbsp;some::path)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The item is visible in the specified path. The path must refer to an ancestor module of the item.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pub(self)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The item is private, i.e. visible only in the same module. This is equivalent to omitting the visibility entirely.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="exports">Exports</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With <code>pub use</code> declarations, items can be <em>re-exported</em> from a different module than the one they were declared in. A re-exported item has multiple paths that refer to the same thing. For example:</p>
</div>
<div class="listingblock">
<div class="title">lib.rs</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">mod</span> <span class="n">answer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="n">ANSWER</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">pub</span> <span class="k">use</span> <span class="nn">answer</span><span class="p">::</span><span class="n">ANSWER</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now <code>ANSWER</code> can be referred to as either <code>crate::ANSWER</code> or <code>crate​::answer::ANSWER</code>. However, not every path is always reachable. Take, for example:</p>
</div>
<div class="listingblock">
<div class="title">lib.rs</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">mod</span> <span class="n">answer</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="n">ANSWER</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">pub</span> <span class="k">use</span> <span class="nn">answer</span><span class="p">::</span><span class="n">ANSWER</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>crate​::answer::ANSWER</code> is public, but it can&#8217;t be used from outside the crate, because the <code>answer</code> module is private. Only the re-export <code>crate::ANSWER</code> can be used from outside the crate.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common-pitfalls">Common pitfalls</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">The module tree must be built manually.</dt>
<dd>
<p>There&#8217;s no implicit mapping from the <em>file system tree</em> to the <em>module tree</em>: We need to declare all modules with the <code>mod</code> keyword.</p>
</dd>
<dt class="hdlist1">Don&#8217;t confuse <em>visibility</em> with <em>reachability</em>.</dt>
<dd>
<p>The visibility of an item is like an <em>upper bound</em>, it can&#8217;t be increased with re-exports. For example, we can&#8217;t re-export a private struct outside of its module.</p>
<div class="paragraph">
<p>However, a public item might not be reachable from outside the crate, if it&#8217;s in a private module and isn&#8217;t publicly re-exported. To make an item available in the crate root, it&#8217;s not enough to make it public; we also need to make it reachable from the crate root.</p>
</div>
</dd>
<dt class="hdlist1">Don&#8217;t confuse <em>visibility</em> with <em>availability</em>.</dt>
<dd>
<p>Visibility means that we are principally allowed to use an item somewhere. It doesn&#8217;t mean that the item is available, i.e. <em>in scope</em>, so we might still have to import it (or refer to it with its path).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="special-cases">Special cases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are a few language constructs that don&#8217;t adhere to the same rules as everything else:</p>
</div>
<div class="sect2">
<h3 id="enum-variants-and-fields">Enum variants and fields</h3>
<div class="paragraph">
<p>Enum variants and variant fields are always public, and it&#8217;s not possible to make them private. Therefore we should be careful when exposing enums publicly, because changing the variants or fields later is not backwards compatible.</p>
</div>
<div class="paragraph">
<p>You can add the <a href="https://doc.rust-lang.org/nightly/reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> attribute to an enum to allow adding more variants later. This mean that the enum can&#8217;t be matched exhaustively; we&#8217;ll always need to add a wildcard match arm (<code>_ =&gt; {}</code>).</p>
</div>
<div class="paragraph">
<p>Sometimes it&#8217;s a good idea to wrap an enum in a struct to hide the implementation details:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">FooImpl</span><span class="p">);</span> <span class="c1">// FooImpl is private</span>

<span class="k">enum</span> <span class="n">FooImpl</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, when an enum variant has multiple fields, it&#8217;s usually better to put them in a separate struct, so it&#8217;s possible to make the fields private or make the struct <code>non_exhaustive</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="c1">// Instead of this:</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">Variant</span> <span class="p">{</span>
        <span class="n">field</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
        <span class="n">other_field</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// do this:</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="nf">Variant</span><span class="p">(</span><span class="n">FooVariant</span><span class="p">),</span>
<span class="p">}</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">FooVariant</span> <span class="p">{</span>
    <span class="n">field</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">other_field</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="macros">Macros</h3>
<div class="paragraph">
<p>Declarative macros (the ones that are declared with <code>macro_rules!</code>) behave more like local variables within a function than like items in some regards. For example, they can be shadowed, they have to be declared before they can be used, and they don&#8217;t need to be explicitly imported in child modules <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>And, they can&#8217;t be declared public. The <code>#[macro_export]</code> attribute can be added to a macro, which exports it publicly at the crate root. This can be undesirable, however, if it&#8217;s not supposed to be part of the public API; there is no equivalent of <code>pub(crate)</code> for macros.</p>
</div>
<div class="paragraph">
<p>One workaround for this is to put our macros in a module and annotate the module with <code>#[macro_use]</code>. The module should be the <em>first module declaration</em> in the crate root. This ensures that the macros can be used everywhere in our crate, but not outside of the crate. Not the most elegant solution, but it works.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-are-modules-declared-explicitly">Why are modules declared explicitly?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I promised to explain why modules have to be declared explicitly. There are a few reasons:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>With the <a href="https://doc.rust-lang.org/reference/items/modules.html#the-path-attribute"><code>#[path]</code></a> attribute, a module can be located in a different directory, or have a different name than the file.</p>
</li>
<li>
<p>Module declarations can have a visibility, e.g. <code>pub(crate) mod foo;</code></p>
</li>
<li>
<p>Sometimes there are files which you don&#8217;t want to include in the module tree.</p>
<div class="paragraph">
<p>For example, a crate with both a library and a binary target usually contains a <code>lib.rs</code> file for the library and a <code>main.rs</code> file for the binary. Submodules are stored in the same directory, but some modules are only needed by the library, and some only by the binary. By specifying the modules explicitly, you can include only the necessary modules in each file.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fin">Fin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I hope you liked this post! Please let me know if you found this article useful; were there any things that were unclear or confusing? I&#8217;ll try to improve it over time.</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/mf2you/rusts_module_system_explained/">Reddit</a>. You can also open an issue in the <a href="https://github.com/Aloso/aloso.github.io/issues">issue tracker</a>.</p>
</div>
<div class="paragraph">
<p>Until next time!</p>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. A crate can also have multiple targets (library, binary, example, test, and benchmark targets), in which case each target has its own root. You can read more about this <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html">here</a>.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. This is called &#8220;textual scoping&#8221;. Actually, macros can have both a textual scope (like local variables) and a path-based scope (like items); the rules for this are <a href="https://doc.rust-lang.org/reference/macros-by-example.html#scoping-exporting-and-importing">quite complicated</a>.
</div>
</div>]]></content><author><name>Ludwig Stecher</name></author><category term="Tutorial" /><summary type="html"><![CDATA[The Rust programming language can be confusing for beginners, and the module system is one part that causes frustration particularly often. There are quite a few blog posts out there trying to explain the module system in a simple way, but I often have the feeling that they over-simplify things. So here&#8217;s my take&#8212;&#8203;a more detailed explanation of the module system.]]></summary></entry><entry><title type="html">Implementing RAII guards in Rust</title><link href="https://aloso.github.io//2021/03/18/raii-guards.html" rel="alternate" type="text/html" title="Implementing RAII guards in Rust" /><published>2021-03-18T00:00:00+00:00</published><updated>2021-03-18T00:00:00+00:00</updated><id>https://aloso.github.io//2021/03/18/raii-guards</id><content type="html" xml:base="https://aloso.github.io//2021/03/18/raii-guards.html"><![CDATA[<div class="paragraph">
<p>As you probably know, Rust doesn&#8217;t have automatic garbage collection. Instead, it relies on destructors to clean up memory, and these destructor calls are automatically inserted in the appropriate places at compile time. And since Rust uses traits for everything, destructors use a trait as well: The <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait.</p>
</div>
<div class="paragraph">
<p>This has the benefit that <code>Drop</code> can be implemented to do anything, not just cleaning up memory: It can also release a file descriptor, close a network socket, cancel an in-flight HTTP request, and much more. Whenever you acquire some sort of resource, and want to release it when you&#8217;re done with it, the <code>Drop</code> trait is your friend.</p>
</div>
<div class="paragraph">
<p>In this blog post we&#8217;ll first look at how the <code>Drop</code> trait works, and then implement the RAII guard pattern, step by step.</p>
</div>
<div class="sect1">
<h2 id="where-is-drop-being-used">Where is <code>Drop</code> being used?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The most common example are heap-allocated containers, such as <code>Box</code>, <code>Vec</code> and <code>String</code>. When such a value goes out of scope, it gets <em>dropped</em>, which means that its <code>Drop</code> implementation is called:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello, world!!"</span><span class="nf">.to_string</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="nf">do_something</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>String is allocated on the heap</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>s</code> is dropped, heap allocation is freed</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another use case are containers that provide <em>interior mutability</em>, such as <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> or <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>. Before we can mutate one of these types, we have to aquire a <em>write lock</em>. Once the write lock is released, it can be aquired again. It is guaranteed that there is at most one write lock at any time, to prevent data races <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Data races</div>
<div class="paragraph">
<p>A race condition is a situation where multiple <em>actors</em> (threads, processes, coroutines, etc.) can access a <em>shared resource</em> at the same time without <em>synchronisation</em>. This may cause <em>data races</em>, which means that the actors influence each other, yielding erroneous results. <code>Mutex</code> provides synchronisation by ensuring that while it&#8217;s mutated by an actor, other actors can&#8217;t access it.</p>
</div>
<div class="paragraph">
<p>For comparison, imagine two cars approaching an intersection from different directions. If the cars enter the intersection at the same time, they crash into one another. The cars are actors, the intersection is a shared resource, and the car crash is a data race. Crashes can be prevented with proper synchronisation, e.g. traffic lights.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="raii">RAII</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RAII stands for “resource acquisition is initialisation”, which is not a very helpful name; it&#8217;s a design pattern and means that every resource is managed by an object; when the object is created, the resource is acquired, and when the object is destroyed, the resource is released. This is what happens in the example above with the <code>String</code>: When <code>s</code> is created, a chunk of memory is acquired. When <code>s</code> is dropped, the memory is released again.</p>
</div>
<div class="paragraph">
<p>However, sometimes it&#8217;s useful to have a type that doesn&#8217;t acquire a resource immediately, and can still be used after the resource has been released. Also, sometimes we want to acquire and release a resource multiple times in a row. That&#8217;s where <em>RAII guards</em> come in.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="raii-guards">RAII guards</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RAII guards is a design pattern for managing a resource when RAII as described above is not flexible enough. It uses <em>two types</em> instead of one: The first one contains a resource (or has a way of acquiring it), but doesn&#8217;t allow us to access the resource directly. It does however have a method for creating an object of the second type. The second type is a <em>RAII guard</em>: It allows us to access the resource, until the RAII guard is dropped.</p>
</div>
<div class="paragraph">
<p>One example of the RAII guards pattern is <code>RefCell</code>. To mutate a <code>RefCell</code>, we have to call its <code>borrow_mut</code> method. This returns a write lock, which is a RAII guard:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">ref_cell</span> <span class="o">=</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">ref_cell</span><span class="nf">.borrow_mut</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="o">*</span><span class="n">guard</span> <span class="o">*=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="p">}</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="nd">dbg!</span><span class="p">(</span><span class="n">ref_cell</span><span class="p">);</span>
<span class="p">}</span> <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The RAII guard is created, which borrows the <code>RefCell</code> and acquires a write lock.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The RAII guard is dropped, which releases the write lock.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>RefCell</code> is dropped.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementation">Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s implement a museum. People can come in and admire the exhibits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Museum</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">Museum</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">admire_exhibits</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"How amazing!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now because of the current pandemic, no more than 20 visitors are allowed inside at any time. To ensure this, the ticket seller has only 20 tickets. Visitors need a ticket to enter the museum, and when they exit, they have to give it back.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Museum</span> <span class="p">{</span>
    <span class="n">remaining_tickets</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Museum</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">Museum</span> <span class="p">{</span>
            <span class="n">remaining_tickets</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_ticket</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ticket</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">self</span><span class="py">.remaining_tickets</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.remaining_tickets</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nf">Ticket</span><span class="p">(()))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">return_ticket</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">ticket</span><span class="p">:</span> <span class="n">Ticket</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.remaining_tickets</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Ticket</span><span class="p">(());</span>

<span class="k">impl</span> <span class="n">Ticket</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">admire_exhibits</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"How amazing!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>How great! We have a <code>Museum</code> and a <code>Ticket</code> type. <code>Ticket</code> has a private field, so it can&#8217;t be created directly from the public API. To get a ticket, one has to call <code>Museum::get_ticket</code>, which ensures that no more than 20 tickets are in circulation.</p>
</div>
<div class="paragraph">
<p>This design suffers from two problems, however: First, if there are multiple museums, we don&#8217;t know which ticket belongs to which museum. Although a visitor can&#8217;t teleport from one museum to another, Rust&#8217;s type system doesn&#8217;t know that, so it allows us to get a ticket from one museum and return it at a different one. This means that more visitors could be in the museum than intended, which is bad during a pandemic. This could be prevented if the tickets had the museum&#8217;s name on it, but that raises the question what to do when a wrong ticket is returned. We&#8217;d really like to avoid having to handle this type of error, if there&#8217;s an alternative.</p>
</div>
<div class="paragraph">
<p>The other problem is that this design doesn&#8217;t force visitors to return their ticket when exiting the museum: If we forget to call <code>Museum::return_ticket</code>, the ticket is lost forever. Once all tickets are lost, nobody will be able to enter the museum, even though it is empty!</p>
</div>
<div class="paragraph">
<p>Both problems can be solved by making <code>Ticket</code> a RAII guard, which borrows the museum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Drop</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Museum</span> <span class="p">{</span>
    <span class="n">remaining_tickets</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Museum</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">Museum</span> <span class="p">{</span>
            <span class="n">remaining_tickets</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_ticket</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ticket</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">self</span><span class="py">.remaining_tickets</span><span class="nf">.borrow_mut</span><span class="p">();</span>
        <span class="k">if</span> <span class="o">*</span><span class="n">lock</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">lock</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">Ticket</span> <span class="p">{</span> <span class="n">museum</span><span class="p">:</span> <span class="k">self</span> <span class="p">})</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Ticket</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">museum</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Museum</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Ticket</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">admire_exhibits</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"How amazing!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">Ticket</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">self</span><span class="py">.museum.remaining_tickets</span><span class="nf">.borrow_mut</span><span class="p">();</span>
        <span class="o">*</span><span class="n">lock</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s what changed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Ticket</code> borrows the <code>Museum</code>, so it can&#8217;t be returned to the wrong museum.</p>
</li>
<li>
<p><code>Museum::get_ticket</code> now takes <code>&amp;self</code> instead of <code>&amp;mut self</code>, because otherwise only one ticket could exist for each museum at a time.</p>
</li>
<li>
<p><code>remaining_tickets</code> is wrapped in a <code>RefCell</code>, which provides interior mutability.</p>
</li>
<li>
<p><code>Museum::return_ticket</code> was replaced with a <code>Drop</code> implementation for <code>Ticket</code>. This ensures that tickets are always returned.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test-it">Test it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As always, it is a good idea to test the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_museum</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">museum</span> <span class="o">=</span> <span class="nn">Museum</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">tickets</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Ticket</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">20</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="n">museum</span><span class="nf">.get_ticket</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="n">museum</span><span class="nf">.get_ticket</span><span class="p">()</span><span class="nf">.is_none</span><span class="p">());</span>
    <span class="n">tickets</span><span class="nf">.pop</span><span class="p">();</span>
    <span class="n">tickets</span><span class="nf">.push</span><span class="p">(</span><span class="n">museum</span><span class="nf">.get_ticket</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">museum</span><span class="py">.remaining_tickets</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">drop</span><span class="p">(</span><span class="n">tickets</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="o">*</span><span class="n">museum</span><span class="py">.remaining_tickets</span><span class="nf">.borrow</span><span class="p">(),</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if the test is in the same module as the code, we can inspect private fields. Now let&#8217;s run the test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="o">&gt;</span> cargo <span class="nb">test</span> <span class="nt">-q</span>

running 1 <span class="nb">test</span>
<strong class="green">.</strong>
<span class="nb">test </span>result: <strong class="green">ok</strong>. 1 passed<span class="p">;</span> 0 failed<span class="p">;</span> 0 ignored<span class="p">;</span> 0 measured<span class="p">;</span> 0 filtered out<span class="p">;</span> finished <span class="k">in </span>0.00s</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="when-drop-isnt-called">When <code>Drop</code> isn&#8217;t called</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Drop</code> implementations (called destructors) are called whenever the scope of the destructor&#8217;s object is exited. It doesn&#8217;t matter <em>how</em> the scope is exited, e.g. it could be because of a <code>return</code>, <code>continue</code> or <code>break</code> statement, a <code>?</code> expression or a panic. There&#8217;s one exception, however: When the process is exited, no destructors are run. This can be done e.g. by invoking <a href="https://doc.rust-lang.org/std/process/fn.abort.html"><code>abort</code></a>, <a href="https://doc.rust-lang.org/std/process/fn.exit.html"><code>exit</code></a>, or by panicking in a <code>Drop</code> implementation during another panic.</p>
</div>
<div class="paragraph">
<p>It is also possible to <em>leak</em> objects, which means that they will never be dropped. This is usually discouraged, but allowed. Objects can be leaked e.g. with the <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> function, or by creating a <a href="https://doc.rust-lang.org/std/rc/">reference-counted</a> graph with a cycle. Another risk are power outages and OS crashes: For obvious reasons, values aren&#8217;t dropped in such cases either.</p>
</div>
<div class="paragraph">
<p>So you can&#8217;t rely on destructors getting called. This is usually not a big problem, but something to be aware of when writing <code>Drop</code> implementations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fin">Fin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/m7fxaz/implementing_raii_guards_in_rust/">Reddit</a>. Please <a href="https://github.com/Aloso/aloso.github.io/issues">file a bug</a> if you have questions, want some things explained in more detail, or if you found a mistake. See you around!</p>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <code>RefCell</code> can&#8217;t actually prevent data races, it only prevents aliasing mutable references, which would violate the ownership rules; <code>RefCell</code> is not thread-safe (it doesn&#8217;t perform locking), so Rust ensures that it can only be used in a single thread. You can use a <code>Mutex</code> or <code>RwLock</code> when you need to access the data from multiple threads.
</div>
</div>]]></content><author><name>Ludwig Stecher</name></author><category term="Tutorial" /><summary type="html"><![CDATA[As you probably know, Rust doesn&#8217;t have automatic garbage collection. Instead, it relies on destructors to clean up memory, and these destructor calls are automatically inserted in the appropriate places at compile time. And since Rust uses traits for everything, destructors use a trait as well: The Drop trait. This has the benefit that Drop can be implemented to do anything, not just cleaning up memory: It can also release a file descriptor, close a network socket, cancel an in-flight HTTP request, and much more. Whenever you acquire some sort of resource, and want to release it when you&#8217;re done with it, the Drop trait is your friend.]]></summary></entry><entry><title type="html">Rust’s Universes</title><link href="https://aloso.github.io//2021/03/10/rusts-universes.html" rel="alternate" type="text/html" title="Rust’s Universes" /><published>2021-03-10T00:00:00+00:00</published><updated>2021-03-10T00:00:00+00:00</updated><id>https://aloso.github.io//2021/03/10/rusts-universes</id><content type="html" xml:base="https://aloso.github.io//2021/03/10/rusts-universes.html"><![CDATA[<div class="paragraph">
<p>This post describes a curious feature of Rust: Namespaces, also called universes. Note that Rust&#8217;s namespaces are nothing like namespaces in languages such as TypeScript or C♯; they are also unrelated to all of space and time, although there are certainly parallels.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It was pointed out that nobody actually calls them universes. The reason I thought that is the following quote from the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/enum.Namespace.html">rustc documentation</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Different kinds of symbols don’t influence each other.</p>
</div>
<div class="paragraph">
<p>Therefore, they have a separate universe (namespace).</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>However, this is more of a <em>figure of speech</em> than a proper term. I apologize for the confusion.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect1">
<h2 id="identifiers">Identifiers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To understand namespaces, we first need to talk about names. Namespaces contain all the names (called <em>identifiers</em>) in Rust code. This does not include keywords, but it includes the names of local variables, types, traits, functions, modules, generic arguments, macros, and so on.</p>
</div>
<div class="paragraph">
<p>Every identifier has a certain scope. For example, local variables are scoped to the block they were defined in, free functions are scoped to their module, trait methods are scoped to their trait, inherent methods to their type. Etcetera. It&#8217;s not possible to use an identifier outside of its scope, unless it was brought into scope with a <code>use</code> statement. So far so good.</p>
</div>
<div class="paragraph">
<p>But what happens when a scope contains multiple things with the same name? Now it gets complicated. In most cases, you&#8217;ll get a compiler error. An exception are local variables and macros, which use <em>textual scoping</em>, and therefore allow <em>shadowing</em> things with the same name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"hello world!"</span><span class="p">;</span>  <span class="c1">// no problemo!</span>

<span class="nd">macro_rules!</span> <span class="n">x</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="nd">macro_rules!</span> <span class="n">x</span> <span class="p">{</span>  <span class="c1">// who cares!</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These are the only exceptions, however. All other things use <em>path-based scoping</em>. While local variables and macros have to be declared before they can be used, things with path-based scoping can be declared and used in any order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">m!</span><span class="p">();</span>  <span class="c1">// error: m is not defined at this point</span>
<span class="nd">macro_rules!</span> <span class="n">m</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">=&gt;</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="nf">f</span><span class="p">();</span>  <span class="c1">// this is fine</span>
<span class="k">fn</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="namespaces">Namespaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>However, path-scoped things have a limitation: There can&#8217;t be more than one thing with the same name defined in the same scope <em>and namespace</em>. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="nf">wtf</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">const</span> <span class="n">wtf</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// error: the name `wtf` is defined multiple times</span>

<span class="k">mod</span> <span class="n">wtf</span> <span class="p">{}</span>  <span class="c1">// this is allowed‽</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Why is that? the function <code>wtf</code> and the constant <code>wtf</code> both live in the same namespace, therefore their names clash. The module <code>wtf</code> however lives in a different namespace, so it can coexist with a function or constant of the same name. One might say, it&#8217;s in a parallel universe.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that constants are usually written in UPPER_CASE, so functions and constants can&#8217;t clash in idiomatic code. I wrote the above code just to prove a point, please don&#8217;t quote me on it. 😉</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So you&#8217;re probably wondering, how many namespaces are there? Let&#8217;s look in the <a href="https://archive.is/ajZHM">documentation of the rustc source</a>! There are 3:</p>
</div>
<div class="ulist compact">
<ul>
<li>
<p>The <em>type namespace</em></p>
</li>
<li>
<p>The <em>value namespace</em></p>
</li>
<li>
<p>The <em>macro namespace</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Which items are part of which namespace is specified <a href="https://archive.is/OZM8P">here</a> in the <code>DefKind</code> type:</p>
</div>
<div class="ulist compact">
<ul>
<li>
<p>The <em>type namespace</em> contains</p>
<div class="ulist">
<ul>
<li>
<p>modules</p>
</li>
<li>
<p>structs</p>
</li>
<li>
<p>enums</p>
</li>
<li>
<p>unions</p>
</li>
<li>
<p>enum variants</p>
</li>
<li>
<p>traits</p>
</li>
<li>
<p>type aliases</p>
</li>
<li>
<p>foreign types</p>
</li>
<li>
<p>trait aliases (currently unstable)</p>
</li>
<li>
<p>associated types</p>
</li>
<li>
<p>type parameters</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <em>value namespace</em> contains</p>
<div class="ulist">
<ul>
<li>
<p>functions</p>
</li>
<li>
<p>constants</p>
</li>
<li>
<p><code>const</code> parameters</p>
</li>
<li>
<p>statics</p>
</li>
<li>
<p>constructors</p>
</li>
<li>
<p>associated functions</p>
</li>
<li>
<p>associated constants</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <em>macro namespace</em> just contains macros.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All other names are treated specially and don&#8217;t fall into any of the above categories.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="what-does-that-mean">What does that mean?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Items with the same name can coexist in the same scope, if they are from different namespaces. One example for this are <em>tuple structs</em>, because they are desugared (i.e. transformed by the compiler) into a regular struct and a constructor function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">Bar</span><span class="p">);</span>

<span class="c1">// the compiler transforms the above into something like this:</span>

<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="n">Bar</span> <span class="p">};</span>

<span class="k">fn</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">_0</span><span class="p">:</span> <span class="n">Bar</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="p">{</span> <span class="mi">0</span><span class="p">:</span> <span class="n">_0</span> <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This isn&#8217;t valid Rust syntax, but that&#8217;s not a problem for the compiler, because the transformation happens internally, after the code was already parsed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So this is why tuple structs can be both used as a type and invoked like a function. However, it also means that tuple structs occupy both the type namespace and the value namespace. Roughly the same happens with enum variants with round brackets. Furthermore, unit structs and unit-like enum variants expand to a type name and a value (a constant), so they also occupy both namespaces.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resolving-names-from-different-namespaces">Resolving names from different namespaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Rust&#8217;s syntax is designed to be unambiguous about the namespace in which the names live. It distinguishes between type positions and value positions, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">fn</span> <span class="nf">a</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">C</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">D</span> <span class="p">{</span>
    <span class="nn">e</span><span class="p">::</span><span class="nn">f</span><span class="p">::</span><span class="n">G</span><span class="py">.h</span><span class="p">::</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Just by looking at the syntax, the compiler can tell that</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>C</code>, <code>D</code>, <code>e</code>, <code>f</code> and <code>I</code> are in the type namespace</p>
</li>
<li>
<p><code>a</code>, <code>b</code>, <code>G</code>, <code>h</code> and <code>j</code> are in the value namespace</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>How does that work? Let&#8217;s start with the obvious ones: <code>a</code> and <code>h</code> are functions, and <code>b</code> is a local variable, so they must be in the value namespace. <code>j</code> is used as a function argument, so it&#8217;s also a value. <code>C</code> and <code>D</code> are used in type positions, so they&#8217;re types. <code>I</code> is used as a generic argument, so it&#8217;s also a type.</p>
</div>
<div class="paragraph">
<p>That only leaves <code>e</code>, <code>f</code> and <code>G</code>. Since <code>e</code> and <code>f</code> are immediately followed by two colons (called the <em>scoping operator</em>), they must be in the type namespace. That makes sense, because types, traits and modules are in the type namespace. <code>G</code> however is followed by a dot, so it is parsed as a value.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Note about const generics</div>
<div class="paragraph">
<p>Recently, a <a href="https://github.com/rust-lang/rust/blob/HEAD/RELEASES.md#version-1510-2021-03-25">MVP of const generics was stabilized</a>. This introduced an ambiguity in the parser: In the expression <code>foo::&lt;X&gt;()</code>, the <code>X</code> can be both a type and a value.</p>
</div>
<div class="paragraph">
<p>Rust resolves this ambiguity by preferring the type when there is both a type <code>X</code> and a value <code>X</code> in scope. If that is incorrect and the function expects a value, it must be wrapped in curly braces, i.e. <code>foo::&lt;{&nbsp;X&nbsp;}&gt;()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="importing-names">Importing names</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Items can be imported with a <code>use</code> item. But how are different namespaces handled? Generally, <code>use</code> imports items from all three namespaces. This means for example, when importing a tuple struct, both its type and its constructor are available.</p>
</div>
<div class="paragraph">
<p>There is an exception, however: When a path ends with <code>::{self}</code> (the curly braces can contain more paths), only the name from the <em>type namespace</em> is imported. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">mod</span> <span class="n">module</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">Foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// import both the type Foo and its constructor:</span>
<span class="k">use</span> <span class="nn">module</span><span class="p">::</span><span class="n">Foo</span><span class="p">;</span>

<span class="c1">// import only the type:</span>
<span class="k">use</span> <span class="nn">module</span><span class="p">::</span><span class="nn">Foo</span><span class="p">::{</span><span class="k">self</span><span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Are you confused yet?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="end">End</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I hope you enjoyed this post, even though it&#8217;s less practically useful than my <a href="https://aloso.github.io/2021/03/09/creating-an-iterator.html">previous post</a>.</p>
</div>
<div class="paragraph">
<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/m1iour/rusts_universes/">Reddit</a>.</p>
</div>
<div class="paragraph">
<p>If you have suggestions what topics I should cover next, please file a bug in the <a href="https://github.com/Aloso/aloso.github.io/issues">issue tracker</a>. Also file a bug if you have questions or want some things explained in more detail, or found a mistake.</p>
</div>
<div class="paragraph">
<p>So long!</p>
</div>
</div>
</div>]]></content><author><name>Ludwig Stecher</name></author><category term="Rust in depth" /><summary type="html"><![CDATA[This post describes a curious feature of Rust: Namespaces, also called universes. Note that Rust&#8217;s namespaces are nothing like namespaces in languages such as TypeScript or C♯; they are also unrelated to all of space and time, although there are certainly parallels.]]></summary></entry><entry><title type="html">Creating an Iterator in Rust</title><link href="https://aloso.github.io//2021/03/09/creating-an-iterator.html" rel="alternate" type="text/html" title="Creating an Iterator in Rust" /><published>2021-03-09T00:00:00+00:00</published><updated>2021-03-09T00:00:00+00:00</updated><id>https://aloso.github.io//2021/03/09/creating-an-iterator</id><content type="html" xml:base="https://aloso.github.io//2021/03/09/creating-an-iterator.html"><![CDATA[<div class="paragraph">
<p>When I woke up today, I thought, what a great day to start a blog! So here we are. Before we take off, just a short introduction: I&#8217;m Ludwig, I&#8217;m a CS student from Germany, and I love Rust. Since this blog is about Rust, I hope you do too!</p>
</div>
<div class="paragraph">
<p>This post is about a core concept in Rust, iterators. If you don&#8217;t know what iterators are, please read <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">the chapter about iterators</a> in the Rust book first.</p>
</div>
<div class="sect1">
<h2 id="the-collection-type">The collection type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Iterators usually iterate over some sort of collection. Our collection type is a tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">enum</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="n">Item</span><span class="p">),</span>
    <span class="nf">Children</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;&gt;</span><span class="p">),</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Simple, right? A tree node is either a <code>Leaf</code>, in which case it contains an <code>Item</code>, or a list of child nodes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-traverse-method">A <code>traverse</code> method</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We want to traverse (i.e. iterate over) this kind of tree <em>depth-first</em>. This means that when a node has multiple children, we first traverse the first child <em>and all its descendants</em> before moving on to the second child. This is easy to implement with a recursive algorithm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{}</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">node</span> <span class="n">in</span> <span class="n">children</span> <span class="p">{</span>
                    <span class="n">node</span><span class="nf">.traverse</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want to do something with each item, we can pass a closure to the function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">It</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nf">f</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">for</span> <span class="n">node</span> <span class="n">in</span> <span class="n">children</span> <span class="p">{</span>
                    <span class="n">node</span><span class="nf">.traverse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows us to iterate over the items. However, <code>Node</code> still doesn&#8217;t implement the <code>Iterator</code> trait, which would be useful because it provides helper methods such as <code>filter</code>, <code>fold</code> and <code>collect</code>.</p>
</div>
<div class="paragraph">
<p>As we will see shortly, implementing this trait is quite tricky in this case. The reason for this is that the <code>Iterator</code> trait provides <em>external iteration</em>, whereas our <code>traverse</code> method provides <em>internal iteration</em>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">External and internal iteration</div>
<div class="paragraph">
<p>Internal iteration means that a closure is passed to a function, which calls the closure for every element. This means that the iterator function has full control over the iteration.</p>
</div>
<div class="paragraph">
<p>External iteration on the other hand means that there&#8217;s a struct with a method to get the next element. This means that the code <em>using</em> the iterator controls the iteration. It can pause the iteration, do something else, pass the iterator to another function and maybe resume it later. External iteration is therefore very powerful and flexible.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementing-the-iterator-trait">Implementing the <code>Iterator</code> trait</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To be able to <em>externally</em> iterate over the tree, we need to implement the <code>Iterator</code> trait. It looks roughly like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The iterator trait is usually not implemented for a collection <em>directly</em>. Instead, a <em>new type</em> is created that wraps the collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Why not implement <code>Iterator</code> for the collection?</div>
<div class="paragraph">
<p>This great question was asked recently on Reddit. One reason is, if the collection implemented the <code>Iterator</code> type directly, the collection could be modified during iteration, which is is error-prone and usually undesired. It would also make it impossible to have multiple iterators that iterate over the same collection simultaneously and independently from each other, because the <code>Iterator::next()</code> method borrows the iterator mutably.</p>
</div>
<div class="paragraph">
<p>More importantly, though, iterators usually need additional state to keep track of the position of the next item in the collection. This state needs to be updated in every iteration, which doesn&#8217;t work if the collection is behind an immutable reference and the state is part of the collection.</p>
</div>
<div class="paragraph">
<p>If the iterator is a separate type, it can be mutable even though the collection is immutable. You&#8217;ll see how this works in a moment, just read on!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As the immutable reference in the <code>NodeIter</code> type indicates, it can only iterate over immutable references of the items. To get an instance of this iterator, we add a <code>.iter()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">NodeIter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can start with the actual implementation!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">It</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">todo!</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now there&#8217;s a problem: Since <code>Iterator</code> provides external iteration, we have to produce one item at a time. This means that we can&#8217;t use the simple recursive algorithm we used in the <code>traverse</code> method. Instead, we have to keep track of the state of the iterator manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">children</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span><span class="p">],</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>children</code> field contains the remaining children of a node, the <code>parent</code> field is the iterator of the parent node, if present. It must be wrapped in a <code>Box</code> because a struct in Rust can&#8217;t contain itself without indirection&#8212;&#8203;otherwise, it would be impossible to compute its size on the stack.</p>
</div>
<div class="paragraph">
<p>So how does this work? When we create the iterator, we put the node into the <code>children</code> slice and set <code>parent</code> to <code>None</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">NodeIter</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">slice</span><span class="p">::</span><span class="nf">from_ref</span><span class="p">(</span><span class="k">self</span><span class="p">),</span>
            <span class="n">parent</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When the iterator is advanced, we first check if <code>children</code> is empty. If that&#8217;s the case, we try to continue iterating the parent node. If there is no parent node, we return <code>None</code>.</p>
</div>
<div class="paragraph">
<p>If <code>children</code> is not empty, we remove the first child and check its variant. If it is a <code>Node::Leaf</code>, we return its content; if it is a <code>Node::Children</code>, we create a new iterator for the children. The <code>parent</code> field is set to <code>self</code>, and <code>self</code> is replaced with the newly created iterator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">mem</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">It</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.children</span><span class="nf">.get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="k">self</span><span class="py">.parent</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// continue with the parent node</span>
                    <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
                    <span class="k">self</span><span class="nf">.next</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.children</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.children</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="n">children</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.children</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.children</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">];</span>

                <span class="c1">// start iterating the child trees</span>
                <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="n">NodeIter</span> <span class="p">{</span>
                    <span class="n">children</span><span class="p">:</span> <span class="n">children</span><span class="nf">.as_slice</span><span class="p">(),</span>
                    <span class="n">parent</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="k">self</span><span class="p">))),</span>
                <span class="p">};</span>
                <span class="k">self</span><span class="nf">.next</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t work yet, because <a href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>mem::take()</code></a> requires that <code>NodeIter</code> implements <code>Default</code>. But this can be fixed easily:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">NodeIter</span> <span class="p">{</span> <span class="n">children</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[],</span> <span class="n">parent</span><span class="p">:</span> <span class="nb">None</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">The <code>mem::take()</code> function</div>
<div class="paragraph">
<p><a href="https://doc.rust-lang.org/std/mem/fn.take.html"><code>mem::take()</code></a> replaces a mutable reference with its default value and returns the previous value. The previous value is effectively <em>moved out</em> of the reference. We use it here to convert <code>&amp;mut self</code> to an owned value, because <code>parent</code> must be owned.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now let&#8217;s see if the iterator works!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing">Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To check if it works, we can write a unit test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_borrowing_iterator</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
        <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
        <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[]),</span>
        <span class="p">]),</span>
        <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
            <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
                <span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">1</span><span class="p">)]),</span>
                <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">]),</span>
        <span class="p">]),</span>
    <span class="p">]);</span>

    <span class="k">let</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">tree</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="o">&gt;</span> cargo <span class="nb">test</span> <span class="nt">-q</span>

running 1 <span class="nb">test</span>
<strong class="green">.</strong>
<span class="nb">test </span>result: <strong class="green">ok</strong>. 1 passed<span class="p">;</span> 0 failed<span class="p">;</span> 0 ignored<span class="p">;</span> 0 measured<span class="p">;</span> 0 filtered out<span class="p">;</span> finished <span class="k">in </span>0.00s</code></pre>
</div>
</div>
<div class="paragraph">
<p>That looks reassuring!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="adding-features">Adding features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have a working iterator, let&#8217;s see how we can improve it. First, let&#8217;s check if we can implement more iterator methods to make it more efficient!</p>
</div>
<div class="sect2">
<h3 id="size-hint">Size hint</h3>
<div class="paragraph">
<p>Every iterator has a size hint, to help the <code>collect</code> methods decide how much memory to allocate when collecting into something like a <code>Vec</code>. By default the lower bound of the size hint is 0, so the <code>collect</code> method might have to re-allocate a few times. This is still better than setting the size hint too high, because that would waste memory.</p>
</div>
<div class="paragraph">
<p>Unfortunately, we don&#8217;t know how many elements a <code>Node</code> contains, and calculating the number of elements would be expensive, so we&#8217;ll skip the <code>size_hint</code> method.</p>
</div>
</div>
<div class="sect2">
<h3 id="fusediterator"><code>FusedIterator</code></h3>
<div class="paragraph">
<p>Sometimes it&#8217;s useful to ensure that after the iterator produces <code>None</code> for the first time, it will only produce <code>None</code> values. Iterators with this property are called <em>fused iterators</em>, and any iterator can be converted to a fused iterator with the <code>.fused()</code> method.</p>
</div>
<div class="paragraph">
<p>However, if we implement the <code>FusedIterator</code> trait for our iterator, calling the <code>.fused()</code> method is more efficient, because it has a specialized implementation for types that implement this trait. So let&#8217;s add it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="n">FusedIterator</span><span class="p">;</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="n">FusedIterator</span> <span class="k">for</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="p">{}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it!</p>
</div>
</div>
<div class="sect2">
<h3 id="intoiterator"><code>IntoIterator</code></h3>
<div class="paragraph">
<p>This trait doesn&#8217;t make the iterator more efficient, just more ergonomic. Implementing <code>IntoIterator</code> for <code>&amp;Node&lt;T&gt;</code> makes it possible to use a node in a <code>for</code> loop without having to write <code>.iter()</code> explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span> <span class="nb">IntoIterator</span> <span class="k">for</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">It</span><span class="p">;</span>

    <span class="k">type</span> <span class="n">IntoIter</span> <span class="o">=</span> <span class="n">NodeIter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">It</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">IntoIter</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.iter</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try it out:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">test_borrowing_for_loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tree</span> <span class="o">=</span> <span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="n">node</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">tree</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">_</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And&#8230;&#8203; it compiles! 🎉</p>
</div>
</div>
<div class="sect2">
<h3 id="an-owned-iterator">An owned iterator</h3>
<div class="paragraph">
<p>We can also implement an iterator that consumes the tree and produces the items as owned values. To implement this iterator, we can copy-paste the borrowed iterator and make a few adjustments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">struct</span> <span class="n">NodeIntoIter</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// we use a VecDeque because it allows</span>
    <span class="c1">// removing elements from the front efficiently <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></span>
    <span class="n">children</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">NodeIntoIter</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="nb">Default</span> <span class="k">for</span> <span class="n">NodeIntoIter</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="n">NodeIntoIter</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
            <span class="n">parent</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="nb">Iterator</span> <span class="k">for</span> <span class="n">NodeIntoIter</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="n">It</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.children</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="k">self</span><span class="py">.parent</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
                <span class="nf">Some</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// continue with the parent node</span>
                    <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
                    <span class="k">self</span><span class="nf">.next</span><span class="p">()</span>
                <span class="p">}</span>
                <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">Leaf</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
            <span class="nf">Some</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">Children</span><span class="p">(</span><span class="n">children</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// start iterating the child trees</span>
                <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="n">NodeIntoIter</span> <span class="p">{</span>
                    <span class="n">children</span><span class="p">:</span> <span class="n">children</span><span class="nf">.into</span><span class="p">(),</span>
                    <span class="n">parent</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">mem</span><span class="p">::</span><span class="nf">take</span><span class="p">(</span><span class="k">self</span><span class="p">))),</span>
                <span class="p">};</span>
                <span class="k">self</span><span class="nf">.next</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s implement <code>IntoIterator</code> for <code>Node</code>, so we can use it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="nb">IntoIterator</span> <span class="k">for</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span> <span class="o">=</span> <span class="n">It</span><span class="p">;</span>

    <span class="k">type</span> <span class="n">IntoIter</span> <span class="o">=</span> <span class="n">NodeIntoIter</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">IntoIter</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">children</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">children</span><span class="nf">.push_back</span><span class="p">(</span><span class="k">self</span><span class="p">);</span>

        <span class="n">NodeIntoIter</span> <span class="p">{</span>
            <span class="n">children</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t forget to test it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sh"><span class="o">&gt;</span> cargo <span class="nb">test</span> <span class="nt">-q</span>

running 4 tests
<strong class="green">....</strong>
<span class="nb">test </span>result: <strong class="green">ok</strong>. 4 passed<span class="p">;</span> 0 failed<span class="p">;</span> 0 ignored<span class="p">;</span> 0 measured<span class="p">;</span> 0 filtered out<span class="p">;</span> finished <span class="k">in </span>0.00s</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="a-mutable-iterator">A mutable iterator</h3>
<div class="paragraph">
<p>Collections usually also have an iterator for mutating the items. They can be particularly tricky to implement safely, because you have to ensure that no part of the iterator is ever borrowed mutably multiple times.</p>
</div>
<div class="paragraph">
<p>But because this blog post is already way too long, I leave this part as an exercise to the reader. 😛</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">How to borrow multiple things from a slice mutably?</div>
<div class="paragraph">
<p>Getting multiple mutable references into a slice isn&#8217;t easy.
One way is to create a mutable iterator with <code>.iter_mut()</code>. Also there&#8217;s a number of methods to help you out:</p>
</div>
<div class="ulist compact">
<ul>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"><code>split_at_mut</code></a></p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first_mut"><code>split_first_mut</code></a></p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last_mut"><code>split_last_mut</code></a></p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_mut"><code>split_mut</code></a></p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive_mut"><code>split_inclusive_mut</code></a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you got stuck implementing this yourself, you may take a peek at <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=936a02346b3a6703d67bf1de9f8d4cd8">this playground</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="what-about-doubleendediterator">What about <code>DoubleEndedIterator</code>?</h3>
<div class="paragraph">
<p><code>DoubleEndedIterator</code> is a trait implemented by iterators that can consume items from both ends. However, we won&#8217;t implement this trait for our iterators, because it would make them much more complicated. And who needs that trait anyway? 😉</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fin">Fin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You should now be able to implement iterators for tree-like data structures.</p>
</div>
<div class="paragraph">
<p>All code is available in this <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=936a02346b3a6703d67bf1de9f8d4cd8">playground</a>. Discussion on <a href="https://www.reddit.com/r/rust/comments/m0wzw7/creating_an_iterator_in_rust/">Reddit</a>.</p>
</div>
<div class="paragraph">
<p>If you have suggestions what topics I should cover next, please file a bug in the <a href="https://github.com/Aloso/aloso.github.io/issues">issue tracker</a>. Also file a bug if you have questions or want some things explained in more detail, or if you found a mistake.</p>
</div>
<div class="paragraph">
<p>I will write posts regularly from now on. If you enjoyed this post, please subscribe to the atom feed (see at the bottom) and share it with your friends! Until next time!</p>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. I was told that you can use a <code>std::vec::IntoIter</code> instead of a <code>VecDeque</code>, which is more efficient, and also more idiomatic. In the same way, a <code>std::slice::Iter</code> can be used for the reference iterator.
</div>
</div>]]></content><author><name>Ludwig Stecher</name></author><category term="Tutorial" /><summary type="html"><![CDATA[When I woke up today, I thought, what a great day to start a blog! So here we are. Before we take off, just a short introduction: I&#8217;m Ludwig, I&#8217;m a CS student from Germany, and I love Rust. Since this blog is about Rust, I hope you do too! This post is about a core concept in Rust, iterators. If you don&#8217;t know what iterators are, please read the chapter about iterators in the Rust book first.]]></summary></entry></feed>